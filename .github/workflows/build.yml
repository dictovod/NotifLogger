name: Build and Test

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Setup Android SDK
      uses: android-actions/setup-android@v3

    - name: Create backup rules
      run: |
        mkdir -p app/src/main/res/xml
        cat > app/src/main/res/xml/backup_rules.xml <<'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <full-backup-content>
        </full-backup-content>
        EOF

    - name: Create data extraction rules
      run: |
        cat > app/src/main/res/xml/data_extraction_rules.xml <<'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <data-extraction-rules>
            <cloud-backup>
            </cloud-backup>
            <device-transfer>
            </device-transfer>
        </data-extraction-rules>
        EOF

    - name: Create MainActivity.java
      run: |
        mkdir -p app/src/main/java/com/example/notificationlogger
        cat > app/src/main/java/com/example/notificationlogger/MainActivity.java <<'EOF'
        package com.example.notificationlogger;

        import android.Manifest;
        import android.content.ClipData;
        import android.content.ClipboardManager;
        import android.content.Context;
        import android.content.Intent;
        import android.content.SharedPreferences;
        import android.content.pm.PackageManager;
        import android.os.Build;
        import android.os.Bundle;
        import android.os.Environment;
        import android.provider.Settings;
        import android.telephony.TelephonyManager;
        import android.view.LayoutInflater;
        import android.view.Menu;
        import android.view.MenuItem;
        import android.view.View;
        import android.view.ViewGroup;
        import android.widget.Button;
        import android.widget.EditText;
        import android.widget.ImageView;
        import android.widget.TextView;
        import android.widget.Toast;

        import androidx.annotation.NonNull;
        import androidx.appcompat.app.AlertDialog;
        import androidx.appcompat.app.AppCompatActivity;
        import androidx.core.app.ActivityCompat;
        import androidx.core.content.ContextCompat;
        import androidx.fragment.app.Fragment;
        import androidx.fragment.app.FragmentManager;
        import androidx.fragment.app.FragmentPagerAdapter;
        import androidx.viewpager.widget.ViewPager;

        import com.google.android.material.tabs.TabLayout;

        import java.text.DateFormat;
        import java.text.ParseException;
        import java.util.Base64;
        import java.util.Date;
        import org.json.JSONException;
        import org.json.JSONObject;

        public class MainActivity extends AppCompatActivity {
            private static final int REQUEST_CODE_NOTIFICATION_LISTENER = 1001;
            private static final int REQUEST_CODE_STORAGE = 1002;
            private static final int REQUEST_CODE_PHONE = 1003;

            private ImageView ivIcon;
            private TextView tvStatus;
            private Button btnNotification, btnStorage;
            private TextView tvImei;
            private Button btnCopyImei;
            private EditText etToken;
            private Button btnActivate;

            private SharedPreferences prefs;
            private boolean isActivated = false;

            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.activity_main);

                prefs = getSharedPreferences("app_prefs", MODE_PRIVATE);
                isActivated = prefs.getBoolean("activated", false);

                ViewPager viewPager = findViewById(R.id.view_pager);
                TabLayout tabLayout = findViewById(R.id.tab_layout);

                viewPager.setAdapter(new TabsAdapter(getSupportFragmentManager()));
                tabLayout.setupWithViewPager(viewPager);

                requestPhonePermission();
                loadActivationStatus();
            }

            private void requestPhonePermission() {
                if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) {
                    ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_PHONE_STATE}, REQUEST_CODE_PHONE);
                }
            }

            private String getImei() {
                if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_PHONE_STATE) == PackageManager.PERMISSION_GRANTED) {
                    TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                        return tm.getImei();
                    } else {
                        return tm.getDeviceId();
                    }
                }
                return "Permission denied";
            }

            private void loadActivationStatus() {
                if (isActivated) {
                    ivIcon.setImageResource(R.drawable.ic_notification_color);
                } else {
                    ivIcon.setImageResource(R.drawable.ic_notification_bw);
                }
            }

            private boolean validateToken(String token) {
                try {
                    byte[] decoded = Base64.getUrlDecoder().decode(token);
                    JSONObject data = new JSONObject(new String(decoded));
                    String tokenImei = data.getString("imei");
                    String startDateStr = data.getString("start_date");
                    long durationSeconds = data.getLong("duration_seconds");

                    String deviceImei = getImei();
                    if (!tokenImei.equals(deviceImei)) {
                        Toast.makeText(this, R.string.imei_mismatch, Toast.LENGTH_SHORT).show();
                        return false;
                    }

                    java.util.Date startDate = DateFormat.getDateTimeInstance().parse(startDateStr);
                    java.util.Date expiryDate = new java.util.Date(startDate.getTime() + durationSeconds * 1000);
                    if (new java.util.Date().after(expiryDate)) {
                        Toast.makeText(this, R.string.token_expired, Toast.LENGTH_SHORT).show();
                        return false;
                    }
                    return true;
                } catch (ParseException | JSONException e) {
                    Toast.makeText(this, R.string.activation_failed, Toast.LENGTH_SHORT).show();
                    return false;
                }
            }

            private void activateApp(String token) {
                if (validateToken(token)) {
                    prefs.edit().putBoolean("activated", true).putString("active_token", token).apply();
                    isActivated = true;
                    loadActivationStatus();
                    Toast.makeText(this, R.string.activation_success, Toast.LENGTH_SHORT).show();
                }
            }

            private class TabsAdapter extends FragmentPagerAdapter {
                public TabsAdapter(FragmentManager fm) {
                    super(fm, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT);
                }

                @Override
                public Fragment getItem(int position) {
                    if (position == 0) return new PermissionsFragment();
                    else return new ActivationFragment();
                }

                @Override
                public int getCount() { return 2; }

                @Override
                public CharSequence getPageTitle(int position) {
                    return position == 0 ? "Разрешения" : getString(R.string.tab_activation);
                }
            }

            public static class PermissionsFragment extends Fragment {
                @Override
                public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
                    View view = inflater.inflate(R.layout.layout_permissions, container, false);
                    ((MainActivity)getActivity()).ivIcon = view.findViewById(R.id.iv_icon);
                    ((MainActivity)getActivity()).tvStatus = view.findViewById(R.id.tv_status);
                    ((MainActivity)getActivity()).btnNotification = view.findViewById(R.id.btn_notification);
                    ((MainActivity)getActivity()).btnStorage = view.findViewById(R.id.btn_storage);

                    ((MainActivity)getActivity()).setupClickListeners();
                    ((MainActivity)getActivity()).updateStatus();
                    ((MainActivity)getActivity()).loadActivationStatus();

                    return view;
                }
            }

            public static class ActivationFragment extends Fragment {
                @Override
                public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
                    View view = inflater.inflate(R.layout.layout_activation, container, false);
                    ((MainActivity)getActivity()).tvImei = view.findViewById(R.id.tv_imei);
                    ((MainActivity)getActivity()).btnCopyImei = view.findViewById(R.id.btn_copy_imei);
                    ((MainActivity)getActivity()).etToken = view.findViewById(R.id.et_token);
                    ((MainActivity)getActivity()).btnActivate = view.findViewById(R.id.btn_activate);

                    ((MainActivity)getActivity()).tvImei.setText(((MainActivity)getActivity()).getImei());

                    ((MainActivity)getActivity()).btnCopyImei.setOnClickListener(v -> {
                        ClipboardManager clipboard = (ClipboardManager) getActivity().getSystemService(Context.CLIPBOARD_SERVICE);
                        ClipData clip = ClipData.newPlainText("IMEI", ((MainActivity)getActivity()).tvImei.getText());
                        clipboard.setPrimaryClip(clip);
                        Toast.makeText(getActivity(), "IMEI скопирован", Toast.LENGTH_SHORT).show();
                    });

                    ((MainActivity)getActivity()).btnActivate.setOnClickListener(v -> {
                        String token = ((MainActivity)getActivity()).etToken.getText().toString().trim();
                        if (!token.isEmpty()) {
                            ((MainActivity)getActivity()).activateApp(token);
                        } else {
                            Toast.makeText(getActivity(), "Введите токен", Toast.LENGTH_SHORT).show();
                        }
                    });

                    return view;
                }
            }

            private void setupClickListeners() {
                btnNotification.setOnClickListener(v -> requestNotificationPermission());
                btnStorage.setOnClickListener(v -> requestStoragePermission());
            }

            private void requestNotificationPermission() {
                if (!isNotificationServiceEnabled()) {
                    Intent intent = new Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS);
                    startActivityForResult(intent, REQUEST_CODE_NOTIFICATION_LISTENER);
                } else {
                    Toast.makeText(this, "Разрешение уже предоставлено", Toast.LENGTH_SHORT).show();
                }
            }

            private void requestStoragePermission() {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                    if (!Environment.isExternalStorageManager()) {
                        Intent intent = new Intent(Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION);
                        startActivityForResult(intent, REQUEST_CODE_STORAGE);
                    } else {
                        Toast.makeText(this, "Разрешение уже предоставлено", Toast.LENGTH_SHORT).show();
                    }
                } else {
                    if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) 
                            != PackageManager.PERMISSION_GRANTED) {
                        ActivityCompat.requestPermissions(this, 
                            new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 
                            REQUEST_CODE_STORAGE);
                    } else {
                        Toast.makeText(this, "Разрешение уже предоставлено", Toast.LENGTH_SHORT).show();
                    }
                }
            }

            private boolean isNotificationServiceEnabled() {
                String pkgName = getPackageName();
                final String flat = Settings.Secure.getString(getContentResolver(), "enabled_notification_listeners");
                if (flat != null && !flat.isEmpty()) {
                    final String[] names = flat.split(":");
                    for (String name : names) {
                        if (name.contains(pkgName)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            private boolean isStoragePermissionGranted() {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                    return Environment.isExternalStorageManager();
                } else {
                    return ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) 
                            == PackageManager.PERMISSION_GRANTED;
                }
            }

            private void updateStatus() {
                boolean notificationGranted = isNotificationServiceEnabled();
                boolean storageGranted = isStoragePermissionGranted();
                
                if (notificationGranted && storageGranted) {
                    tvStatus.setText(R.string.permissions_granted);
                } else {
                    tvStatus.setText(R.string.permissions_required);
                }
            }

            @Override
            protected void onActivityResult(int requestCode, int resultCode, Intent data) {
                super.onActivityResult(requestCode, resultCode, data);
                if (requestCode == REQUEST_CODE_NOTIFICATION_LISTENER || requestCode == REQUEST_CODE_STORAGE) {
                    updateStatus();
                }
            }

            @Override
            public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, 
                    @NonNull int[] grantResults) {
                super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                if (requestCode == REQUEST_CODE_STORAGE || requestCode == REQUEST_CODE_PHONE) {
                    updateStatus();
                }
            }

            @Override
            protected void onResume() {
                super.onResume();
                updateStatus();
            }

            @Override
            public boolean onCreateOptionsMenu(Menu menu) {
                getMenuInflater().inflate(R.menu.main_menu, menu);
                return true;
            }

            @Override
            public boolean onOptionsItemSelected(@NonNull MenuItem item) {
                int id = item.getItemId();
                if (id == R.id.menu_about) {
                    new AlertDialog.Builder(this)
                            .setTitle(R.string.app_name)
                            .setMessage(R.string.about_text)
                            .setPositiveButton("OK", null)
                            .show();
                    return true;
                } else if (id == R.id.menu_exit) {
                    finish();
                    return true;
                }
                return super.onOptionsItemSelected(item);
            }
        }
        EOF

    - name: Create NotificationListener.java
      run: |
        cat > app/src/main/java/com/example/notificationlogger/NotificationListener.java <<'EOF'
        package com.example.notificationlogger;

        import android.app.Notification;
        import android.content.ContentValues;
        import android.content.SharedPreferences;
        import android.database.sqlite.SQLiteDatabase;
        import android.os.Build;
        import android.os.Environment;
        import android.service.notification.NotificationListenerService;
        import android.service.notification.StatusBarNotification;
        import android.util.Log;

        import java.io.File;
        import java.io.FileWriter;
        import java.io.IOException;
        import java.text.SimpleDateFormat;
        import java.util.Date;
        import java.util.Locale;

        public class NotificationListener extends NotificationListenerService {
            private static final String TAG = "NotificationLogger";
            private DatabaseHelper dbHelper;
            private FileWriter logFileWriter;
            private SharedPreferences prefs;

            @Override
            public void onCreate() {
                super.onCreate();
                prefs = getSharedPreferences("app_prefs", MODE_PRIVATE);
                dbHelper = new DatabaseHelper(this);
                initLogFile();
                Log.d(TAG, "NotificationListener service created");
            }

            private void initLogFile() {
                try {
                    File logDir;
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                        logDir = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS), "NotificationLogger");
                    } else {
                        logDir = new File(getExternalFilesDir(null), "logs");
                    }
                    
                    if (!logDir.exists()) {
                        logDir.mkdirs();
                    }
                    
                    File logFile = new File(logDir, "notifications.log");
                    logFileWriter = new FileWriter(logFile, true);
                    Log.d(TAG, "Log file initialized: " + logFile.getAbsolutePath());
                } catch (IOException e) {
                    Log.e(TAG, "Error initializing log file", e);
                }
            }

            @Override
            public void onDestroy() {
                super.onDestroy();
                if (logFileWriter != null) {
                    try {
                        logFileWriter.close();
                    } catch (IOException e) {
                        Log.e(TAG, "Error closing log file", e);
                    }
                }
                Log.d(TAG, "NotificationListener service destroyed");
            }

            @Override
            public void onNotificationPosted(StatusBarNotification sbn) {
                if (!prefs.getBoolean("activated", false)) {
                    Log.d(TAG, "App not activated, skipping notification");
                    return;
                }

                try {
                    Notification notification = sbn.getNotification();
                    if (notification == null) {
                        Log.w(TAG, "Null notification received");
                        return;
                    }

                    String packageName = sbn.getPackageName();
                    String title = "";
                    String text = "";
                    
                    if (notification.extras != null) {
                        CharSequence titleSeq = notification.extras.getCharSequence(Notification.EXTRA_TITLE);
                        CharSequence textSeq = notification.extras.getCharSequence(Notification.EXTRA_TEXT);
                        
                        title = titleSeq != null ? titleSeq.toString() : "";
                        text = textSeq != null ? textSeq.toString() : "";
                    }

                    String timestamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
                            .format(new Date());

                    if (dbHelper.isDuplicate(packageName, title, text)) {
                        Log.d(TAG, "Duplicate notification skipped: " + packageName);
                        return;
                    }

                    saveToDatabase(timestamp, packageName, title, text);
                    saveToLogFile(timestamp, packageName, title, text);
                    dbHelper.updateMetadata(packageName, timestamp);
                    
                    Log.d(TAG, String.format("Notification logged: %s | %s | %s", 
                            packageName, title, text));
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error processing notification", e);
                }
            }

            private void saveToDatabase(String timestamp, String packageName, String title, String text) {
                try {
                    SQLiteDatabase db = dbHelper.getAppDatabase(packageName);
                    String tableName = packageName.replace(".", "_");
                    ContentValues values = new ContentValues();
                    values.put("timestamp", timestamp);
                    values.put("title", title);
                    values.put("text", text);
                    db.insert(tableName, null, values);
                } catch (Exception e) {
                    Log.e(TAG, "Error saving to database", e);
                }
            }

            private void saveToLogFile(String timestamp, String packageName, String title, String text) {
                if (logFileWriter != null) {
                    try {
                        String logEntry = String.format("%s | %s | %s | %s%n", 
                                timestamp, packageName, title, text);
                        logFileWriter.write(logEntry);
                        logFileWriter.flush();
                    } catch (IOException e) {
                        Log.e(TAG, "Error writing to log file", e);
                    }
                }
            }

            @Override
            public void onNotificationRemoved(StatusBarNotification sbn) {
                // Optional: handle notification removal
            }
        }
        EOF

    - name: Create DatabaseHelper.java
      run: |
        cat > app/src/main/java/com/example/notificationlogger/DatabaseHelper.java <<'EOF'
        package com.example.notificationlogger;

        import android.content.Context;
        import android.database.Cursor;
        import android.database.sqlite.SQLiteDatabase;
        import android.database.sqlite.SQLiteOpenHelper;
        import android.os.Environment;

        import java.io.File;

        public class DatabaseHelper extends SQLiteOpenHelper {
            private static final String DATABASE_NAME = "notifications.db";
            private static final int DATABASE_VERSION = 1;
            private static final String METADATA_TABLE = "metadata";
            private static final String COLUMN_ID = "id";
            private static final String COLUMN_TIMESTAMP = "timestamp";
            private static final String COLUMN_PACKAGE = "package_name";
            private static final String COLUMN_TITLE = "title";
            private static final String COLUMN_TEXT = "text";
            private static final String COLUMN_DB_NAME = "db_name";
            private static final String COLUMN_ROW_COUNT = "row_count";

            private static final String CREATE_METADATA_TABLE =
                    "CREATE TABLE " + METADATA_TABLE + " (" +
                            COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " +
                            COLUMN_TIMESTAMP + " TEXT NOT NULL, " +
                            COLUMN_PACKAGE + " TEXT NOT NULL, " +
                            COLUMN_DB_NAME + " TEXT NOT NULL, " +
                            COLUMN_ROW_COUNT + " INTEGER NOT NULL)";

            private final Context context;

            public DatabaseHelper(Context context) {
                super(context, getDatabasePath(context), null, DATABASE_VERSION);
                this.context = context;
            }

            private static String getDatabasePath(Context context) {
                File dbDir = new File(context.getExternalFilesDir(null), "databases");
                if (!dbDir.exists()) {
                    dbDir.mkdirs();
                }
                return new File(dbDir, DATABASE_NAME).getAbsolutePath();
            }

            @Override
            public void onCreate(SQLiteDatabase db) {
                db.execSQL(CREATE_METADATA_TABLE);
            }

            @Override
            public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
                db.execSQL("DROP TABLE IF EXISTS " + METADATA_TABLE);
                Cursor cursor = db.rawQuery("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' AND name != ?", 
                        new String[]{METADATA_TABLE});
                while (cursor.moveToNext()) {
                    db.execSQL("DROP TABLE IF EXISTS " + cursor.getString(0));
                }
                cursor.close();
                onCreate(db);
            }

            public SQLiteDatabase getAppDatabase(String packageName) {
                String tableName = packageName.replace(".", "_");
                SQLiteDatabase db = getWritableDatabase();
                String createTableQuery =
                        "CREATE TABLE IF NOT EXISTS " + tableName + " (" +
                                COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " +
                                COLUMN_TIMESTAMP + " TEXT NOT NULL, " +
                                COLUMN_TITLE + " TEXT, " +
                                COLUMN_TEXT + " TEXT)";
                db.execSQL(createTableQuery);
                return db;
            }

            public boolean isDuplicate(String packageName, String title, String text) {
                String tableName = packageName.replace(".", "_");
                SQLiteDatabase db = getReadableDatabase();
                String query = "SELECT " + COLUMN_TITLE + ", " + COLUMN_TEXT + " FROM " + tableName +
                        " WHERE " + COLUMN_TITLE + " = ? AND " + COLUMN_TEXT + " = ? " +
                        " ORDER BY " + COLUMN_TIMESTAMP + " DESC LIMIT 1";
                Cursor cursor = db.rawQuery(query, new String[]{title, text});
                boolean isDuplicate = cursor.moveToFirst();
                cursor.close();
                return isDuplicate;
            }

            public void updateMetadata(String packageName, String timestamp) {
                String tableName = packageName.replace(".", "_");
                SQLiteDatabase db = getWritableDatabase();
                Cursor cursor = db.rawQuery("SELECT COUNT(*) FROM " + tableName, null);
                int rowCount = 0;
                if (cursor.moveToFirst()) {
                    rowCount = cursor.getInt(0);
                }
                cursor.close();

                db.execSQL("INSERT OR REPLACE INTO " + METADATA_TABLE + " (" +
                                COLUMN_TIMESTAMP + ", " + COLUMN_PACKAGE + ", " + COLUMN_DB_NAME + ", " + COLUMN_ROW_COUNT + ") " +
                                "VALUES (?, ?, ?, ?)",
                        new Object[]{timestamp, packageName, tableName, rowCount});
            }
        }
        EOF

    - name: Build with Gradle
      run: ./gradlew clean assembleDebug --stacktrace

    - name: Upload build logs
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: build-logs
        path: app/build/reports/ gradle-*.log
        retention-days: 3
        if-no-files-found: warn