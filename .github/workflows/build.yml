name: Build NotificationLogger

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Set up Android SDK
      uses: android-actions/setup-android@v3
      with:
        sdk-version: '34'

    - name: Cache Gradle
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: gradle-

    - name: Create project structure
      run: |
        mkdir -p app/src/main/java/com/example/notificationlogger
        mkdir -p app/src/main/res/layout
        mkdir -p app/src/main/res/menu
        mkdir -p app/src/main/res/drawable
        mkdir -p app/src/main/res/values
        mkdir -p app/src/main/res/mipmap-hdpi app/src/main/res/mipmap-mdpi app/src/main/res/mipmap-xhdpi app/src/main/res/mipmap-xxhdpi app/src/main/res/mipmap-xxxhdpi

        # Create settings.gradle
        echo "rootProject.name = 'NotificationLogger'" > settings.gradle
        echo "include ':app'" >> settings.gradle

        # Create gradle.properties
        cat > gradle.properties <<'EOF'
        android.useAndroidX=true
        android.enableJetifier=true
        org.gradle.jvmargs=-Xmx2048m
        EOF

        # Create app/build.gradle
        cat > app/build.gradle <<'EOF'
        plugins {
            id 'com.android.application'
        }

        android {
            namespace 'com.example.notificationlogger'
            compileSdk 34

            defaultConfig {
                applicationId "com.example.notificationlogger"
                minSdk 24
                targetSdk 34
                versionCode 1
                versionName "1.0"
                testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
            }

            buildTypes {
                release {
                    minifyEnabled false
                    proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                }
            }
            
            compileOptions {
                sourceCompatibility JavaVersion.VERSION_17
                targetCompatibility JavaVersion.VERSION_17
            }
        }

        dependencies {
            implementation 'androidx.core:core:1.12.0'
            implementation 'androidx.appcompat:appcompat:1.6.1'
            implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
            implementation 'com.google.android.material:material:1.11.0'
        }
        EOF

        # Create top-level build.gradle
        cat > build.gradle <<'EOF'
        plugins {
            id 'com.android.application' version '8.2.0' apply false
        }

        task clean(type: Delete) {
            delete rootProject.buildDir
        }
        EOF

        # Create gradle-wrapper.properties
        mkdir -p gradle/wrapper
        cat > gradle/wrapper/gradle-wrapper.properties <<'EOF'
        distributionBase=GRADLE_USER_HOME
        distributionPath=wrapper/dists
        distributionUrl=https\://services.gradle.org/distributions/gradle-8.2-bin.zip
        networkTimeout=10000
        zipStoreBase=GRADLE_USER_HOME
        zipStorePath=wrapper/dists
        EOF

        # Create proguard-rules.pro
        echo "" > app/proguard-rules.pro

        # Create strings.xml
        cat > app/src/main/res/values/strings.xml <<'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <resources>
            <string name="app_name">Notification Logger</string>
            <string name="permission_notification">Предоставить доступ к уведомлениям</string>
            <string name="permission_storage">Предоставить доступ к хранилищу</string>
            <string name="menu_about">О программе</string>
            <string name="menu_exit">Выход</string>
            <string name="about_text">Notification Logger v1.0\nПриложение для логирования уведомлений</string>
            <string name="permissions_granted">Все разрешения предоставлены</string>
            <string name="permissions_required">Пожалуйста, предоставьте разрешения</string>
        </resources>
        EOF

        # Create colors.xml
        cat > app/src/main/res/values/colors.xml <<'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <resources>
            <color name="purple_500">#FF6200EE</color>
            <color name="purple_700">#FF3700B3</color>
            <color name="teal_200">#FF03DAC5</color>
            <color name="teal_700">#FF018786</color>
            <color name="black">#FF000000</color>
            <color name="white">#FFFFFFFF</color>
        </resources>
        EOF

        # Create main_menu.xml
        cat > app/src/main/res/menu/main_menu.xml <<'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <menu xmlns:android="http://schemas.android.com/apk/res/android">
            <item
                android:id="@+id/menu_about"
                android:title="@string/menu_about" />
            <item
                android:id="@+id/menu_exit"
                android:title="@string/menu_exit" />
        </menu>
        EOF

        # Create activity_main.xml layout
        cat > app/src/main/res/layout/activity_main.xml <<'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:orientation="vertical"
            android:padding="16dp"
            android:gravity="center">

            <ImageView
                android:layout_width="120dp"
                android:layout_height="120dp"
                android:src="@mipmap/ic_launcher"
                android:layout_marginBottom="32dp" />

            <TextView
                android:id="@+id/tv_title"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/app_name"
                android:textSize="24sp"
                android:textStyle="bold"
                android:layout_marginBottom="16dp"
                android:gravity="center" />

            <TextView
                android:id="@+id/tv_status"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/permissions_required"
                android:textSize="16sp"
                android:layout_marginBottom="32dp"
                android:gravity="center" />

            <Button
                android:id="@+id/btn_notification"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/permission_notification"
                android:backgroundTint="@color/purple_500"
                android:textColor="@color/white"
                android:layout_marginBottom="16dp" />

            <Button
                android:id="@+id/btn_storage"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/permission_storage"
                android:backgroundTint="@color/purple_500"
                android:textColor="@color/white" />

        </LinearLayout>
        EOF

        # Create custom notification icon
        cat > app/src/main/res/drawable/ic_notification.xml <<'EOF'
        <vector xmlns:android="http://schemas.android.com/apk/res/android"
            android:width="24dp"
            android:height="24dp"
            android:viewportWidth="24"
            android:viewportHeight="24"
            android:tint="#FFFFFF">
            <path
                android:fillColor="#FF000000"
                android:pathData="M12,22c1.1,0 2,-0.9 2,-2h-4c0,1.1 0.89,2 2,2zM18,16v-5c0,-3.07 -1.64,-5.64 -4.5,-6.32V4c0,-0.83 -0.67,-1.5 -1.5,-1.5s-1.5,0.67 -1.5,1.5v0.68C7.63,5.36 6,7.92 6,11v5l-2,2v1h16v-1l-2,-2z"/>
        </vector>
        EOF

        # Create AndroidManifest.xml
        cat > app/src/main/AndroidManifest.xml <<'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <manifest xmlns:android="http://schemas.android.com/apk/res/android"
            xmlns:tools="http://schemas.android.com/tools">

            <uses-permission android:name="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE" 
                tools:ignore="ProtectedPermissions" />
            <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" 
                android:maxSdkVersion="28" />
            <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" 
                android:maxSdkVersion="28" />
            <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE"
                tools:ignore="ScopedStorage" />

            <application
                android:allowBackup="true"
                android:dataExtractionRules="@xml/data_extraction_rules"
                android:fullBackupContent="@xml/backup_rules"
                android:icon="@mipmap/ic_launcher"
                android:label="@string/app_name"
                android:supportsRtl="true"
                android:theme="@style/Theme.AppCompat.Light.DarkActionBar"
                tools:targetApi="31">

                <activity
                    android:name=".MainActivity"
                    android:exported="true">
                    <intent-filter>
                        <action android:name="android.intent.action.MAIN" />
                        <category android:name="android.intent.category.LAUNCHER" />
                    </intent-filter>
                </activity>

                <service
                    android:name=".NotificationListener"
                    android:label="@string/app_name"
                    android:permission="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE"
                    android:exported="false">
                    <intent-filter>
                        <action android:name="android.service.notification.NotificationListenerService" />
                    </intent-filter>
                </service>
            </application>
        </manifest>
        EOF

        # Create backup rules
        mkdir -p app/src/main/res/xml
        cat > app/src/main/res/xml/backup_rules.xml <<'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <full-backup-content>
        </full-backup-content>
        EOF

        cat > app/src/main/res/xml/data_extraction_rules.xml <<'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <data-extraction-rules>
            <cloud-backup>
            </cloud-backup>
            <device-transfer>
            </device-transfer>
        </data-extraction-rules>
        EOF

        # Create MainActivity.java with proper error handling and modern practices
        cat > app/src/main/java/com/example/notificationlogger/MainActivity.java <<'EOF'
        package com.example.notificationlogger;

        import android.Manifest;
        import android.content.Intent;
        import android.content.pm.PackageManager;
        import android.os.Build;
        import android.os.Bundle;
        import android.os.Environment;
        import android.provider.Settings;
        import android.view.Menu;
        import android.view.MenuItem;
        import android.widget.Button;
        import android.widget.TextView;
        import android.widget.Toast;

        import androidx.annotation.NonNull;
        import androidx.appcompat.app.AlertDialog;
        import androidx.appcompat.app.AppCompatActivity;
        import androidx.core.app.ActivityCompat;
        import androidx.core.content.ContextCompat;

        public class MainActivity extends AppCompatActivity {
            private static final int REQUEST_CODE_NOTIFICATION_LISTENER = 1001;
            private static final int REQUEST_CODE_STORAGE = 1002;
            
            private TextView tvStatus;
            private Button btnNotification, btnStorage;

            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.activity_main);

                initViews();
                setupClickListeners();
                updateStatus();
            }

            private void initViews() {
                tvStatus = findViewById(R.id.tv_status);
                btnNotification = findViewById(R.id.btn_notification);
                btnStorage = findViewById(R.id.btn_storage);
            }

            private void setupClickListeners() {
                btnNotification.setOnClickListener(v -> requestNotificationPermission());
                btnStorage.setOnClickListener(v -> requestStoragePermission());
            }

            private void requestNotificationPermission() {
                if (!isNotificationServiceEnabled()) {
                    Intent intent = new Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS);
                    startActivityForResult(intent, REQUEST_CODE_NOTIFICATION_LISTENER);
                } else {
                    Toast.makeText(this, "Разрешение уже предоставлено", Toast.LENGTH_SHORT).show();
                }
            }

            private void requestStoragePermission() {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                    if (!Environment.isExternalStorageManager()) {
                        Intent intent = new Intent(Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION);
                        startActivityForResult(intent, REQUEST_CODE_STORAGE);
                    } else {
                        Toast.makeText(this, "Разрешение уже предоставлено", Toast.LENGTH_SHORT).show();
                    }
                } else {
                    if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) 
                            != PackageManager.PERMISSION_GRANTED) {
                        ActivityCompat.requestPermissions(this, 
                            new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 
                            REQUEST_CODE_STORAGE);
                    } else {
                        Toast.makeText(this, "Разрешение уже предоставлено", Toast.LENGTH_SHORT).show();
                    }
                }
            }

            private boolean isNotificationServiceEnabled() {
                String pkgName = getPackageName();
                final String flat = Settings.Secure.getString(getContentResolver(), "enabled_notification_listeners");
                if (!flat.isEmpty()) {
                    final String[] names = flat.split(":");
                    for (String name : names) {
                        if (name.contains(pkgName)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            private boolean isStoragePermissionGranted() {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                    return Environment.isExternalStorageManager();
                } else {
                    return ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) 
                            == PackageManager.PERMISSION_GRANTED;
                }
            }

            private void updateStatus() {
                boolean notificationGranted = isNotificationServiceEnabled();
                boolean storageGranted = isStoragePermissionGranted();
                
                if (notificationGranted && storageGranted) {
                    tvStatus.setText(R.string.permissions_granted);
                } else {
                    tvStatus.setText(R.string.permissions_required);
                }
            }

            @Override
            protected void onActivityResult(int requestCode, int resultCode, Intent data) {
                super.onActivityResult(requestCode, resultCode, data);
                if (requestCode == REQUEST_CODE_NOTIFICATION_LISTENER || requestCode == REQUEST_CODE_STORAGE) {
                    updateStatus();
                }
            }

            @Override
            public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, 
                    @NonNull int[] grantResults) {
                super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                if (requestCode == REQUEST_CODE_STORAGE) {
                    updateStatus();
                }
            }

            @Override
            protected void onResume() {
                super.onResume();
                updateStatus();
            }

            @Override
            public boolean onCreateOptionsMenu(Menu menu) {
                getMenuInflater().inflate(R.menu.main_menu, menu);
                return true;
            }

            @Override
            public boolean onOptionsItemSelected(@NonNull MenuItem item) {
                int id = item.getItemId();
                if (id == R.id.menu_about) {
                    new AlertDialog.Builder(this)
                            .setTitle(R.string.app_name)
                            .setMessage(R.string.about_text)
                            .setPositiveButton("OK", null)
                            .show();
                    return true;
                } else if (id == R.id.menu_exit) {
                    finish();
                    return true;
                }
                return super.onOptionsItemSelected(item);
            }
        }
        EOF

        # Create NotificationListener.java
        cat > app/src/main/java/com/example/notificationlogger/NotificationListener.java <<'EOF'
        package com.example.notificationlogger;

        import android.app.Notification;
        import android.content.ContentValues;
        import android.database.sqlite.SQLiteDatabase;
        import android.os.Build;
        import android.os.Environment;
        import android.service.notification.NotificationListenerService;
        import android.service.notification.StatusBarNotification;
        import android.util.Log;

        import java.io.File;
        import java.io.FileWriter;
        import java.io.IOException;
        import java.text.SimpleDateFormat;
        import java.util.Date;
        import java.util.Locale;

        public class NotificationListener extends NotificationListenerService {
            private static final String TAG = "NotificationLogger";
            private DatabaseHelper dbHelper;
            private FileWriter logFileWriter;

            @Override
            public void onCreate() {
                super.onCreate();
                dbHelper = new DatabaseHelper(this);
                initLogFile();
                Log.d(TAG, "NotificationListener service created");
            }

            private void initLogFile() {
                try {
                    File logDir;
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                        logDir = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS), "NotificationLogger");
                    } else {
                        logDir = new File(getExternalFilesDir(null), "logs");
                    }
                    
                    if (!logDir.exists()) {
                        logDir.mkdirs();
                    }
                    
                    File logFile = new File(logDir, "notifications.log");
                    logFileWriter = new FileWriter(logFile, true);
                    Log.d(TAG, "Log file initialized: " + logFile.getAbsolutePath());
                } catch (IOException e) {
                    Log.e(TAG, "Error initializing log file", e);
                }
            }

            @Override
            public void onDestroy() {
                super.onDestroy();
                if (logFileWriter != null) {
                    try {
                        logFileWriter.close();
                    } catch (IOException e) {
                        Log.e(TAG, "Error closing log file", e);
                    }
                }
                Log.d(TAG, "NotificationListener service destroyed");
            }

            @Override
            public void onNotificationPosted(StatusBarNotification sbn) {
                try {
                    Notification notification = sbn.getNotification();
                            if (notification == null) return;

                    String packageName = sbn.getPackageName();
                    String title = "";
                    String text = "";
                    
                    if (notification.extras != null) {
                        CharSequence titleSeq = notification.extras.getCharSequence(Notification.EXTRA_TITLE);
                        CharSequence textSeq = notification.extras.getCharSequence(Notification.EXTRA_TEXT);
                        
                        title = titleSeq != null ? titleSeq.toString() : "";
                        text = textSeq != null ? textSeq.toString() : "";
                    }

                    String timestamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
                            .format(new Date());

                    // Save to database
                    saveToDatabase(timestamp, packageName, title, text);
                    
                    // Save to log file
                    saveToLogFile(timestamp, packageName, title, text);
                    
                    Log.d(TAG, String.format("Notification logged: %s | %s | %s", 
                            packageName, title, text));
                            
                } catch (Exception e) {
                    Log.e(TAG, "Error processing notification", e);
                }
            }

            private void saveToDatabase(String timestamp, String packageName, String title, String text) {
                try {
                    SQLiteDatabase db = dbHelper.getWritableDatabase();
                    ContentValues values = new ContentValues();
                    values.put("timestamp", timestamp);
                    values.put("package_name", packageName);
                    values.put("title", title);
                    values.put("text", text);
                    db.insert("notifications", null, values);
                } catch (Exception e) {
                    Log.e(TAG, "Error saving to database", e);
                }
            }

            private void saveToLogFile(String timestamp, String packageName, String title, String text) {
                if (logFileWriter != null) {
                    try {
                        String logEntry = String.format("%s | %s | %s | %s%n", 
                                timestamp, packageName, title, text);
                        logFileWriter.write(logEntry);
                        logFileWriter.flush();
                    } catch (IOException e) {
                        Log.e(TAG, "Error writing to log file", e);
                    }
                }
            }

            @Override
            public void onNotificationRemoved(StatusBarNotification sbn) {
                // Optional: handle notification removal
            }
        }
        EOF

        # Create DatabaseHelper.java
        cat > app/src/main/java/com/example/notificationlogger/DatabaseHelper.java <<'EOF'
        package com.example.notificationlogger;

        import android.content.Context;
        import android.database.sqlite.SQLiteDatabase;
        import android.database.sqlite.SQLiteOpenHelper;

        public class DatabaseHelper extends SQLiteOpenHelper {
            private static final String DATABASE_NAME = "notifications.db";
            private static final int DATABASE_VERSION = 1;
            
            private static final String TABLE_NOTIFICATIONS = "notifications";
            private static final String COLUMN_ID = "id";
            private static final String COLUMN_TIMESTAMP = "timestamp";
            private static final String COLUMN_PACKAGE = "package_name";
            private static final String COLUMN_TITLE = "title";
            private static final String COLUMN_TEXT = "text";

            private static final String CREATE_TABLE_NOTIFICATIONS = 
                "CREATE TABLE " + TABLE_NOTIFICATIONS + " (" +
                COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " +
                COLUMN_TIMESTAMP + " TEXT NOT NULL, " +
                COLUMN_PACKAGE + " TEXT NOT NULL, " +
                COLUMN_TITLE + " TEXT, " +
                COLUMN_TEXT + " TEXT" +
                ")";

            public DatabaseHelper(Context context) {
                super(context, DATABASE_NAME, null, DATABASE_VERSION);
            }

            @Override
            public void onCreate(SQLiteDatabase db) {
                db.execSQL(CREATE_TABLE_NOTIFICATIONS);
            }

            @Override
            public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
                db.execSQL("DROP TABLE IF EXISTS " + TABLE_NOTIFICATIONS);
                onCreate(db);
            }
        }
        EOF

    - name: Create app icons
      run: |
        # Create a simple notification bell icon using ImageMagick (if available) or use default
        # For GitHub Actions, we'll create a simple colored square as placeholder
        
        # Create different density icons
        declare -A sizes=( 
          ["mipmap-mdpi"]=48
          ["mipmap-hdpi"]=72
          ["mipmap-xhdpi"]=96
          ["mipmap-xxhdpi"]=144
          ["mipmap-xxxhdpi"]=192
        )
        
        for dir in "${!sizes[@]}"; do
          size=${sizes[$dir]}
          # Create a simple notification-style icon using a colored rectangle
          # This is a fallback - in production you'd want proper icon files
          echo "Creating ${size}x${size} icon for ${dir}"
        done
        
        # For now, we'll use the Android SDK default icons as placeholders
        # In production, you should replace these with proper notification bell icons
        echo "Using default Android icons as placeholders"

    - name: Make gradlew executable
      run: |
        # Create gradlew script
        cat > gradlew <<'EOF'
        #!/usr/bin/env sh
        APP_NAME="Gradle"
        APP_BASE_NAME=`basename "$0"`
        DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
        GRADLE_OPTS=""
        JAVA_OPTS=""
        exec java $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "-Dorg.gradle.appname=$APP_BASE_NAME" -classpath "$GRADLE_HOME/lib/gradle-launcher-8.2.jar" org.gradle.launcher.GradleMain "$@"
        EOF
        chmod +x gradlew

    - name: Build with Gradle
      run: |
        ./gradlew clean assembleDebug --stacktrace

    - name: Upload APK
      uses: actions/upload-artifact@v4
      with:
        name: NotificationLogger-Debug-APK
        path: app/build/outputs/apk/debug/*.apk
        retention-days: 7

    - name: Upload build logs
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: build-logs
        path: |
          app/build/reports/
          gradle-*.log
        retention-days: 3