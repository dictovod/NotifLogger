name: Build NotificationLogger

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Set up Android SDK
      uses: android-actions/setup-android@v3
      with:
        sdk-version: '34'

    - name: Cache Gradle
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: gradle-

    - name: Download and set up Gradle
      run: |
        GRADLE_VERSION="8.2.1"
        wget -q https://services.gradle.org/distributions/gradle-${GRADLE_VERSION}-bin.zip -O gradle.zip
        unzip -q gradle.zip
        export PATH=$PWD/gradle-${GRADLE_VERSION}/bin:$PATH
        gradle --version

    - name: Create project structure
      run: |
        mkdir -p app/src/main/java/com/example/notificationlogger
        mkdir -p app/src/main/res/layout
        mkdir -p app/src/main/res/menu
        mkdir -p app/src/main/res/mipmap-hdpi app/src/main/res/mipmap-mdpi app/src/main/res/mipmap-xhdpi app/src/main/res/mipmap-xxhdpi app/src/main/res/mipmap-xxxhdpi

        # Create settings.gradle
        echo "rootProject.name = 'NotificationLogger'" > settings.gradle
        echo "include ':app'" >> settings.gradle

        # Create gradle.properties
        echo "android.useAndroidX=true" > gradle.properties

        # Create app/build.gradle
        cat > app/build.gradle <<'EOF'
        apply plugin: 'com.android.application'
        apply plugin: 'kotlin-android'

        android {
            namespace 'com.example.notificationlogger'
            compileSdk 34

            defaultConfig {
                applicationId "com.example.notificationlogger"
                minSdk 24
                targetSdk 34
                versionCode 1
                versionName "1.0"
            }

            buildTypes {
                release {
                    minifyEnabled false
                    proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                }
            }
            compileOptions {
                sourceCompatibility JavaVersion.VERSION_17
                targetCompatibility JavaVersion.VERSION_17
            }
            kotlinOptions {
                jvmTarget = '17'
            }
        }

        dependencies {
            implementation 'androidx.core:core:1.12.0'
            implementation 'androidx.appcompat:appcompat:1.6.1'
            implementation 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
            implementation('androidx.appcompat:appcompat:1.6.1') {
                exclude group: 'org.jetbrains.kotlin', module: 'kotlin-stdlib-jdk7'
                exclude group: 'org.jetbrains.kotlin', module: 'kotlin-stdlib-jdk8'
            }
        }
        EOF

        # Create top-level build.gradle
        cat > build.gradle <<'EOF'
        buildscript {
            repositories {
                google()
                mavenCentral()
            }
            dependencies {
                classpath 'com.android.tools.build:gradle:8.2.0'
                classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.8.22'
            }
        }

        allprojects {
            repositories {
                google()
                mavenCentral()
            }
        }
        EOF

        # Create gradle-wrapper.properties
        mkdir -p gradle/wrapper
        cat > gradle/wrapper/gradle-wrapper.properties <<EOF
        distributionBase=GRADLE_USER_HOME
        distributionPath=wrapper/dists
        distributionUrl=https\://services.gradle.org/distributions/gradle-8.2.1-bin.zip
        zipStoreBase=GRADLE_USER_HOME
        zipStorePath=wrapper/dists
        EOF

        # Create proguard-rules.pro
        echo "" > app/proguard-rules.pro

        # Create main_menu.xml
        cat > app/src/main/res/menu/main_menu.xml <<'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <menu xmlns:android="http://schemas.android.com/apk/res/android">
            <item
                android:id="@+id/menu_about"
                android:title="О программе" />
            <item
                android:id="@+id/menu_exit"
                android:title="Выход" />
        </menu>
        EOF

        # Create AndroidManifest.xml
        cat > app/src/main/AndroidManifest.xml <<'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <manifest xmlns:android="http://schemas.android.com/apk/res/android"
            xmlns:tools="http://schemas.android.com/tools"
            package="com.example.notificationlogger">

            <uses-permission android:name="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE" tools:ignore="ProtectedPermissions" />
            <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
            <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />

            <application
                android:allowBackup="true"
                android:label="Notification Logger"
                android:supportsRtl="true"
                android:icon="@mipmap/ic_launcher_playstore">

                <activity
                    android:name=".MainActivity"
                    android:exported="true">
                    <intent-filter>
                        <action android:name="android.intent.action.MAIN" />
                        <category android:name="android.intent.category.LAUNCHER" />
                    </intent-filter>
                </activity>

                <service
                    android:name=".MainActivity$MyNotificationListener"
                    android:label="Notification Logger Service"
                    android:permission="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE"
                    android:exported="false">
                    <intent-filter>
                        <action android:name="android.service.notification.NotificationListenerService" />
                    </intent-filter>
                </service>
            </application>
        </manifest>
        EOF

        # Create MainActivity.java
        cat > app/src/main/java/com/example/notificationlogger/MainActivity.java <<'EOF'
        package com.example.notificationlogger;

        import android.app.Activity;
        import android.app.Notification;
        import android.content.ContentValues;
        import android.content.Context;
        import android.content.Intent;
        import android.database.sqlite.SQLiteDatabase;
        import android.database.sqlite.SQLiteOpenHelper;
        import android.os.Bundle;
        import android.os.Environment;
        import android.provider.Settings;
        import android.service.notification.NotificationListenerService;
        import android.service.notification.StatusBarNotification;
        import android.util.Log;
        import android.view.Menu;
        import android.view.MenuItem;
        import android.view.View;
        import android.widget.Button;
        import android.widget.LinearLayout;
        import android.widget.TextView;
        import android.widget.Toast;
        import androidx.core.app.ActivityCompat;
        import androidx.core.content.ContextCompat;
        import android.content.pm.PackageManager;
        import android.Manifest;

        import java.io.File;
        import java.io.FileWriter;
        import java.io.IOException;
        import java.text.SimpleDateFormat;
        import java.util.Date;
        import java.util.Locale;

        public class MainActivity extends Activity {
            private static final int REQUEST_CODE_NOTIFICATION_LISTENER = 1;
            private static final int REQUEST_CODE_STORAGE = 2;

            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);

                LinearLayout layout = new LinearLayout(this);
                layout.setOrientation(LinearLayout.VERTICAL);
                layout.setPadding(16, 16, 16, 16);

                TextView tv = new TextView(this);
                tv.setText("Notification Logger");
                layout.addView(tv);

                Button btnNotification = new Button(this);
                btnNotification.setText("Предоставить доступ к уведомлениям");
                btnNotification.setBackgroundColor(0xFF6200EE);
                btnNotification.setTextColor(0xFFFFFFFF);
                btnNotification.setOnClickListener(v -> requestNotificationPermission());
                layout.addView(btnNotification);

                Button btnStorage = new Button(this);
                btnStorage.setText("Предоставить доступ к хранилищу");
                btnStorage.setBackgroundColor(0xFF6200EE);
                btnStorage.setTextColor(0xFFFFFFFF);
                btnStorage.setOnClickListener(v -> requestStoragePermission());
                layout.addView(btnStorage);

                if (checkPermissions()) {
                    tv.append("\nВсе разрешения предоставлены.");
                } else {
                    tv.append("\nПожалуйста, предоставьте разрешения.");
                }

                setContentView(layout);
            }

            private void requestNotificationPermission() {
                Intent intent = new Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS);
                startActivityForResult(intent, REQUEST_CODE_NOTIFICATION_LISTENER);
            }

            private void requestStoragePermission() {
                if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED ||
                    ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
                    ActivityCompat.requestPermissions(this, new String[]{
                        Manifest.permission.WRITE_EXTERNAL_STORAGE,
                        Manifest.permission.READ_EXTERNAL_STORAGE
                    }, REQUEST_CODE_STORAGE);
                }
            }

            private boolean checkPermissions() {
                boolean notificationGranted = Settings.Secure.getString(getContentResolver(), "enabled_notification_listeners").contains(getApplicationContext().getPackageName());
                boolean storageGranted = ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED &&
                                        ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED;
                return notificationGranted && storageGranted;
            }

            @Override
            protected void onActivityResult(int requestCode, int resultCode, Intent data) {
                super.onActivityResult(requestCode, resultCode, data);
                if (requestCode == REQUEST_CODE_NOTIFICATION_LISTENER) {
                    if (checkPermissions()) {
                        Toast.makeText(this, "Все разрешения предоставлены.", Toast.LENGTH_SHORT).show();
                    }
                }
            }

            @Override
            public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
                super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                if (requestCode == REQUEST_CODE_STORAGE) {
                    if (checkPermissions()) {
                        Toast.makeText(this, "Все разрешения предоставлены.", Toast.LENGTH_SHORT).show();
                    }
                }
            }

            @Override
            public boolean onCreateOptionsMenu(Menu menu) {
                getMenuInflater().inflate(R.menu.main_menu, menu);
                return true;
            }

            @Override
            public boolean onOptionsItemSelected(MenuItem item) {
                int id = item.getItemId();
                if (id == R.id.menu_about) {
                    Toast.makeText(this, "Notification Logger v1.0\nBy xAI", Toast.LENGTH_LONG).show();
                    return true;
                } else if (id == R.id.menu_exit) {
                    finish();
                    return true;
                }
                return super.onOptionsItemSelected(item);
            }

            public static class DBHelper extends SQLiteOpenHelper {
                public DBHelper(Context context) {
                    super(context, "notifications.db", null, 1);
                }
                @Override
                public void onCreate(SQLiteDatabase db) {
                    db.execSQL("CREATE TABLE IF NOT EXISTS notifications (" +
                            "id INTEGER PRIMARY KEY AUTOINCREMENT," +
                            "timestamp TEXT," +
                            "package TEXT," +
                            "title TEXT," +
                            "text TEXT)");
                }
                @Override
                public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
                    db.execSQL("DROP TABLE IF EXISTS notifications");
                    onCreate(db);
                }
            }

            public static class MyNotificationListener extends NotificationListenerService {
                private static final String TAG = "NotifLogger";
                private DBHelper dbHelper;
                private FileWriter logFile;

                @Override
                public void onCreate() {
                    super.onCreate();
                    dbHelper = new DBHelper(this);
                    try {
                        File logDir = new File(Environment.getExternalStorageDirectory(), "Android/data/com.example.notificationlogger/files");
                        if (!logDir.exists()) {
                            logDir.mkdirs();
                        }
                        File logFilePath = new File(logDir, "notifications.log");
                        logFile = new FileWriter(logFilePath, true);
                    } catch (IOException e) {
                        Log.e(TAG, "Ошибка открытия файла", e);
                    }
                }

                @Override
                public void onDestroy() {
                    super.onDestroy();
                    try {
                        if (logFile != null) logFile.close();
                    } catch (IOException e) {
                        Log.e(TAG, "Ошибка закрытия файла", e);
                    }
                }

                @Override
                public void onNotificationPosted(StatusBarNotification sbn) {
                    Notification n = sbn.getNotification();
                    if (n == null) return;
                    CharSequence titleCs = n.extras.getCharSequence(Notification.EXTRA_TITLE);
                    CharSequence textCs = n.extras.getCharSequence(Notification.EXTRA_TEXT);
                    String pkg = sbn.getPackageName();
                    String title = titleCs != null ? titleCs.toString() : "";
                    String text = textCs != null ? textCs.toString() : "";
                    String timestamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(new Date());
                    SQLiteDatabase db = dbHelper.getWritableDatabase();
                    ContentValues cv = new ContentValues();
                    cv.put("timestamp", timestamp);
                    cv.put("package", pkg);
                    cv.put("title", title);
                    cv.put("text", text);
                    db.insert("notifications", null, cv);
                    String logLine = timestamp + " | " + pkg + " | " + title + " | " + text + "\n";
                    Log.i(TAG, logLine);
                    try {
                        if (logFile != null) {
                            logFile.write(logLine);
                            logFile.flush();
                        }
                    } catch (IOException e) {
                        Log.e(TAG, "Ошибка записи", e);
                    }
                }

                @Override
                public void onNotificationRemoved(StatusBarNotification sbn) {}
            }
        }
        EOF

        # Copy ic_launcher_playstore icon from Android SDK with force overwrite
        cp -rf $ANDROID_HOME/platforms/android-34/data/res/mipmap-*/* app/src/main/res/

    - name: Build with Gradle
      run: |
        export PATH=$PWD/gradle-8.2.1/bin:$PATH
        gradle assembleDebug

    - name: Upload APK
      uses: actions/upload-artifact@v4
      with:
        name: NotificationLogger-Debug-APK
        path: app/build/outputs/apk/debug/*.apk
        retention-days: 7